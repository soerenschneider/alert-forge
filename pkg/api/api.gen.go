// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for GetAllAlertsParamsContentType.
const (
	GetAllAlertsParamsContentTypeApplicationjson GetAllAlertsParamsContentType = "application/json"
	GetAllAlertsParamsContentTypeTexthtml        GetAllAlertsParamsContentType = "text/html"
)

// Defines values for GetAlertsByInstanceParamsContentType.
const (
	GetAlertsByInstanceParamsContentTypeApplicationjson GetAlertsByInstanceParamsContentType = "application/json"
	GetAlertsByInstanceParamsContentTypeTexthtml        GetAlertsByInstanceParamsContentType = "text/html"
)

// Defines values for GetAlertsBySeverityParamsContentType.
const (
	GetAlertsBySeverityParamsContentTypeApplicationjson GetAlertsBySeverityParamsContentType = "application/json"
	GetAlertsBySeverityParamsContentTypeTexthtml        GetAlertsBySeverityParamsContentType = "text/html"
)

// Defines values for GetAlertsTodayParamsContentType.
const (
	GetAlertsTodayParamsContentTypeApplicationjson GetAlertsTodayParamsContentType = "application/json"
	GetAlertsTodayParamsContentTypeTexthtml        GetAlertsTodayParamsContentType = "text/html"
)

// Defines values for GetAlertsYesterdayParamsContentType.
const (
	GetAlertsYesterdayParamsContentTypeApplicationjson GetAlertsYesterdayParamsContentType = "application/json"
	GetAlertsYesterdayParamsContentTypeTexthtml        GetAlertsYesterdayParamsContentType = "text/html"
)

// Defines values for StatisticsParamsAccept.
const (
	StatisticsParamsAcceptApplicationjson StatisticsParamsAccept = "application/json"
	StatisticsParamsAcceptTexthtml        StatisticsParamsAccept = "text/html"
)

// Alert defines model for Alert.
type Alert struct {
	Annotations  map[string]string `json:"annotations,omitempty"`
	EndsAt       time.Time         `json:"endsAt,omitempty"`
	Fingerprint  string            `json:"fingerprint,omitempty"`
	GeneratorURL string            `json:"generatorURL,omitempty"`
	Labels       map[string]string `json:"labels,omitempty"`
	Receivers    []struct {
		Name string `json:"name,omitempty"`
	} `json:"receivers,omitempty"`
	StartsAt  time.Time `json:"startsAt,omitempty"`
	Status    Status    `json:"status,omitempty"`
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
}

// Status defines model for Status.
type Status struct {
	InhibitedBy []string `json:"inhibitedBy,omitempty"`
	SilencedBy  []string `json:"silencedBy,omitempty"`
	State       string   `json:"state,omitempty"`
}

// GetAllAlertsParams defines parameters for GetAllAlerts.
type GetAllAlertsParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAllAlertsParamsContentType `json:"Content-Type,omitempty"`
}

// GetAllAlertsParamsContentType defines parameters for GetAllAlerts.
type GetAllAlertsParamsContentType string

// GetAlertsByInstanceParams defines parameters for GetAlertsByInstance.
type GetAlertsByInstanceParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsByInstanceParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsByInstanceParamsContentType defines parameters for GetAlertsByInstance.
type GetAlertsByInstanceParamsContentType string

// GetAlertsBySeverityParams defines parameters for GetAlertsBySeverity.
type GetAlertsBySeverityParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsBySeverityParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsBySeverityParamsContentType defines parameters for GetAlertsBySeverity.
type GetAlertsBySeverityParamsContentType string

// GetAlertsTodayParams defines parameters for GetAlertsToday.
type GetAlertsTodayParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsTodayParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsTodayParamsContentType defines parameters for GetAlertsToday.
type GetAlertsTodayParamsContentType string

// GetAlertsYesterdayParams defines parameters for GetAlertsYesterday.
type GetAlertsYesterdayParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsYesterdayParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsYesterdayParamsContentType defines parameters for GetAlertsYesterday.
type GetAlertsYesterdayParamsContentType string

// StatisticsParams defines parameters for Statistics.
type StatisticsParams struct {
	// Accept Specify `application/json` or `text/html` to request JSON or HTML format.
	Accept *StatisticsParamsAccept `json:"Accept,omitempty"`
}

// StatisticsParamsAccept defines parameters for Statistics.
type StatisticsParamsAccept string

// CreateAlertJSONBody defines parameters for CreateAlert.
type CreateAlertJSONBody struct {
	Alerts []struct {
		Annotations  map[string]string `json:"annotations,omitempty"`
		EndsAt       time.Time         `json:"endsAt,omitempty"`
		Fingerprint  string            `json:"fingerprint,omitempty"`
		GeneratorURL string            `json:"generatorURL,omitempty"`
		Labels       map[string]string `json:"labels,omitempty"`
		StartsAt     time.Time         `json:"startsAt,omitempty"`
		Status       string            `json:"status,omitempty"`
	} `json:"alerts,omitempty"`
	CommonAnnotations map[string]string `json:"commonAnnotations,omitempty"`
	CommonLabels      map[string]string `json:"commonLabels,omitempty"`
	ExternalURL       string            `json:"externalURL,omitempty"`
	GroupKey          string            `json:"groupKey,omitempty"`
	GroupLabels       map[string]string `json:"groupLabels,omitempty"`
	Receiver          string            `json:"receiver,omitempty"`
	Status            string            `json:"status,omitempty"`
	TruncatedAlerts   int               `json:"truncatedAlerts,omitempty"`
	Version           string            `json:"version,omitempty"`
}

// CreateAlertJSONRequestBody defines body for CreateAlert for application/json ContentType.
type CreateAlertJSONRequestBody CreateAlertJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllAlerts request
	GetAllAlerts(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsByInstance request
	GetAlertsByInstance(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsBySeverity request
	GetAlertsBySeverity(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsToday request
	GetAlertsToday(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsYesterday request
	GetAlertsYesterday(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Statistics request
	Statistics(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAlertWithBody request with any body
	CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllAlerts(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsByInstance(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsByInstanceRequest(c.Server, instance, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsBySeverity(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsBySeverityRequest(c.Server, severity, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsToday(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsTodayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsYesterday(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsYesterdayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Statistics(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatisticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllAlertsRequest generates requests for GetAllAlerts
func NewGetAllAlertsRequest(server string, params *GetAllAlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsByInstanceRequest generates requests for GetAlertsByInstance
func NewGetAlertsByInstanceRequest(server string, instance string, params *GetAlertsByInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsBySeverityRequest generates requests for GetAlertsBySeverity
func NewGetAlertsBySeverityRequest(server string, severity string, params *GetAlertsBySeverityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "severity", runtime.ParamLocationPath, severity)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/severity/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsTodayRequest generates requests for GetAlertsToday
func NewGetAlertsTodayRequest(server string, params *GetAlertsTodayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/today")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsYesterdayRequest generates requests for GetAlertsYesterday
func NewGetAlertsYesterdayRequest(server string, params *GetAlertsYesterdayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/yesterday")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewStatisticsRequest generates requests for Statistics
func NewStatisticsRequest(server string, params *StatisticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAlertRequest calls the generic CreateAlert builder with application/json body
func NewCreateAlertRequest(server string, body CreateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAlertRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAlertRequestWithBody generates requests for CreateAlert with any type of body
func NewCreateAlertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllAlertsWithResponse request
	GetAllAlertsWithResponse(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*GetAllAlertsResponse, error)

	// GetAlertsByInstanceWithResponse request
	GetAlertsByInstanceWithResponse(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*GetAlertsByInstanceResponse, error)

	// GetAlertsBySeverityWithResponse request
	GetAlertsBySeverityWithResponse(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*GetAlertsBySeverityResponse, error)

	// GetAlertsTodayWithResponse request
	GetAlertsTodayWithResponse(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*GetAlertsTodayResponse, error)

	// GetAlertsYesterdayWithResponse request
	GetAlertsYesterdayWithResponse(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*GetAlertsYesterdayResponse, error)

	// StatisticsWithResponse request
	StatisticsWithResponse(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*StatisticsResponse, error)

	// CreateAlertWithBodyWithResponse request with any body
	CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error)

	CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error)
}

type GetAllAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAllAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsByInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsByInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsByInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsBySeverityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsBySeverityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsBySeverityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsTodayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsTodayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsTodayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsYesterdayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsYesterdayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsYesterdayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AlertDuration *[]struct {
			AverageDuration *int    `json:"average_duration,omitempty"`
			Name            *string `json:"name,omitempty"`
		} `json:"alert_duration,omitempty"`
		AlertsByDay *[]struct {
			AlertCount *int                `json:"alert_count,omitempty"`
			AlertDate  *openapi_types.Date `json:"alert_date,omitempty"`
		} `json:"alerts_by_day,omitempty"`
		AlertsByInstance *[]struct {
			Instance      *string `json:"instance,omitempty"`
			InstanceCount *int    `json:"instance_count,omitempty"`
		} `json:"alerts_by_instance,omitempty"`
		AlertsBySeverity *[]struct {
			AlertCount *int    `json:"alert_count,omitempty"`
			Severity   *string `json:"severity,omitempty"`
		} `json:"alerts_by_severity,omitempty"`
		AvgAlertDurationBySeverity *[]struct {
			AverageDuration *int    `json:"average_duration,omitempty"`
			Severity        *string `json:"severity,omitempty"`
		} `json:"avg_alert_duration_by_severity,omitempty"`
	}
	JSON400 *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllAlertsWithResponse request returning *GetAllAlertsResponse
func (c *ClientWithResponses) GetAllAlertsWithResponse(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*GetAllAlertsResponse, error) {
	rsp, err := c.GetAllAlerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAlertsResponse(rsp)
}

// GetAlertsByInstanceWithResponse request returning *GetAlertsByInstanceResponse
func (c *ClientWithResponses) GetAlertsByInstanceWithResponse(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*GetAlertsByInstanceResponse, error) {
	rsp, err := c.GetAlertsByInstance(ctx, instance, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsByInstanceResponse(rsp)
}

// GetAlertsBySeverityWithResponse request returning *GetAlertsBySeverityResponse
func (c *ClientWithResponses) GetAlertsBySeverityWithResponse(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*GetAlertsBySeverityResponse, error) {
	rsp, err := c.GetAlertsBySeverity(ctx, severity, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsBySeverityResponse(rsp)
}

// GetAlertsTodayWithResponse request returning *GetAlertsTodayResponse
func (c *ClientWithResponses) GetAlertsTodayWithResponse(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*GetAlertsTodayResponse, error) {
	rsp, err := c.GetAlertsToday(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsTodayResponse(rsp)
}

// GetAlertsYesterdayWithResponse request returning *GetAlertsYesterdayResponse
func (c *ClientWithResponses) GetAlertsYesterdayWithResponse(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*GetAlertsYesterdayResponse, error) {
	rsp, err := c.GetAlertsYesterday(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsYesterdayResponse(rsp)
}

// StatisticsWithResponse request returning *StatisticsResponse
func (c *ClientWithResponses) StatisticsWithResponse(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*StatisticsResponse, error) {
	rsp, err := c.Statistics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatisticsResponse(rsp)
}

// CreateAlertWithBodyWithResponse request with arbitrary body returning *CreateAlertResponse
func (c *ClientWithResponses) CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error) {
	rsp, err := c.CreateAlertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResponse(rsp)
}

func (c *ClientWithResponses) CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error) {
	rsp, err := c.CreateAlert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResponse(rsp)
}

// ParseGetAllAlertsResponse parses an HTTP response from a GetAllAlertsWithResponse call
func ParseGetAllAlertsResponse(rsp *http.Response) (*GetAllAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsByInstanceResponse parses an HTTP response from a GetAlertsByInstanceWithResponse call
func ParseGetAlertsByInstanceResponse(rsp *http.Response) (*GetAlertsByInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsByInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsBySeverityResponse parses an HTTP response from a GetAlertsBySeverityWithResponse call
func ParseGetAlertsBySeverityResponse(rsp *http.Response) (*GetAlertsBySeverityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsBySeverityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsTodayResponse parses an HTTP response from a GetAlertsTodayWithResponse call
func ParseGetAlertsTodayResponse(rsp *http.Response) (*GetAlertsTodayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsTodayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsYesterdayResponse parses an HTTP response from a GetAlertsYesterdayWithResponse call
func ParseGetAlertsYesterdayResponse(rsp *http.Response) (*GetAlertsYesterdayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsYesterdayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseStatisticsResponse parses an HTTP response from a StatisticsWithResponse call
func ParseStatisticsResponse(rsp *http.Response) (*StatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AlertDuration *[]struct {
				AverageDuration *int    `json:"average_duration,omitempty"`
				Name            *string `json:"name,omitempty"`
			} `json:"alert_duration,omitempty"`
			AlertsByDay *[]struct {
				AlertCount *int                `json:"alert_count,omitempty"`
				AlertDate  *openapi_types.Date `json:"alert_date,omitempty"`
			} `json:"alerts_by_day,omitempty"`
			AlertsByInstance *[]struct {
				Instance      *string `json:"instance,omitempty"`
				InstanceCount *int    `json:"instance_count,omitempty"`
			} `json:"alerts_by_instance,omitempty"`
			AlertsBySeverity *[]struct {
				AlertCount *int    `json:"alert_count,omitempty"`
				Severity   *string `json:"severity,omitempty"`
			} `json:"alerts_by_severity,omitempty"`
			AvgAlertDurationBySeverity *[]struct {
				AverageDuration *int    `json:"average_duration,omitempty"`
				Severity        *string `json:"severity,omitempty"`
			} `json:"avg_alert_duration_by_severity,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseCreateAlertResponse parses an HTTP response from a CreateAlertWithResponse call
func ParseCreateAlertResponse(rsp *http.Response) (*CreateAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+Ju+yUXtubeJOaur1f8CAAD//zuFezy2OAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
