// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for GetAllAlertsParamsContentType.
const (
	GetAllAlertsParamsContentTypeApplicationjson GetAllAlertsParamsContentType = "application/json"
	GetAllAlertsParamsContentTypeTexthtml        GetAllAlertsParamsContentType = "text/html"
)

// Defines values for GetAlertsByInstanceParamsContentType.
const (
	GetAlertsByInstanceParamsContentTypeApplicationjson GetAlertsByInstanceParamsContentType = "application/json"
	GetAlertsByInstanceParamsContentTypeTexthtml        GetAlertsByInstanceParamsContentType = "text/html"
)

// Defines values for GetAlertsBySeverityParamsContentType.
const (
	GetAlertsBySeverityParamsContentTypeApplicationjson GetAlertsBySeverityParamsContentType = "application/json"
	GetAlertsBySeverityParamsContentTypeTexthtml        GetAlertsBySeverityParamsContentType = "text/html"
)

// Defines values for GetAlertsTodayParamsContentType.
const (
	GetAlertsTodayParamsContentTypeApplicationjson GetAlertsTodayParamsContentType = "application/json"
	GetAlertsTodayParamsContentTypeTexthtml        GetAlertsTodayParamsContentType = "text/html"
)

// Defines values for GetAlertsYesterdayParamsContentType.
const (
	GetAlertsYesterdayParamsContentTypeApplicationjson GetAlertsYesterdayParamsContentType = "application/json"
	GetAlertsYesterdayParamsContentTypeTexthtml        GetAlertsYesterdayParamsContentType = "text/html"
)

// Defines values for StatisticsParamsAccept.
const (
	StatisticsParamsAcceptApplicationjson StatisticsParamsAccept = "application/json"
	StatisticsParamsAcceptTexthtml        StatisticsParamsAccept = "text/html"
)

// Alert defines model for Alert.
type Alert struct {
	Annotations  map[string]string `json:"annotations,omitempty"`
	EndsAt       time.Time         `json:"endsAt,omitempty"`
	Fingerprint  string            `json:"fingerprint,omitempty"`
	GeneratorURL string            `json:"generatorURL,omitempty"`
	Labels       map[string]string `json:"labels,omitempty"`
	Receivers    []struct {
		Name string `json:"name,omitempty"`
	} `json:"receivers,omitempty"`
	StartsAt  time.Time `json:"startsAt,omitempty"`
	Status    Status    `json:"status,omitempty"`
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
}

// Status defines model for Status.
type Status struct {
	InhibitedBy []string `json:"inhibitedBy,omitempty"`
	SilencedBy  []string `json:"silencedBy,omitempty"`
	State       string   `json:"state,omitempty"`
}

// GetAllAlertsParams defines parameters for GetAllAlerts.
type GetAllAlertsParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAllAlertsParamsContentType `json:"Content-Type,omitempty"`
}

// GetAllAlertsParamsContentType defines parameters for GetAllAlerts.
type GetAllAlertsParamsContentType string

// GetAlertsByInstanceParams defines parameters for GetAlertsByInstance.
type GetAlertsByInstanceParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsByInstanceParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsByInstanceParamsContentType defines parameters for GetAlertsByInstance.
type GetAlertsByInstanceParamsContentType string

// GetAlertsBySeverityParams defines parameters for GetAlertsBySeverity.
type GetAlertsBySeverityParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsBySeverityParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsBySeverityParamsContentType defines parameters for GetAlertsBySeverity.
type GetAlertsBySeverityParamsContentType string

// GetAlertsTodayParams defines parameters for GetAlertsToday.
type GetAlertsTodayParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsTodayParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsTodayParamsContentType defines parameters for GetAlertsToday.
type GetAlertsTodayParamsContentType string

// GetAlertsYesterdayParams defines parameters for GetAlertsYesterday.
type GetAlertsYesterdayParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsYesterdayParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsYesterdayParamsContentType defines parameters for GetAlertsYesterday.
type GetAlertsYesterdayParamsContentType string

// StatisticsParams defines parameters for Statistics.
type StatisticsParams struct {
	// Accept Specify `application/json` or `text/html` to request JSON or HTML format.
	Accept *StatisticsParamsAccept `json:"Accept,omitempty"`
}

// StatisticsParamsAccept defines parameters for Statistics.
type StatisticsParamsAccept string

// CreateAlertJSONBody defines parameters for CreateAlert.
type CreateAlertJSONBody struct {
	Alerts []struct {
		Annotations  map[string]string `json:"annotations,omitempty"`
		EndsAt       time.Time         `json:"endsAt,omitempty"`
		Fingerprint  string            `json:"fingerprint,omitempty"`
		GeneratorURL string            `json:"generatorURL,omitempty"`
		Labels       map[string]string `json:"labels,omitempty"`
		StartsAt     time.Time         `json:"startsAt,omitempty"`
		Status       string            `json:"status,omitempty"`
	} `json:"alerts,omitempty"`
	CommonAnnotations map[string]string `json:"commonAnnotations,omitempty"`
	CommonLabels      map[string]string `json:"commonLabels,omitempty"`
	ExternalURL       string            `json:"externalURL,omitempty"`
	GroupKey          string            `json:"groupKey,omitempty"`
	GroupLabels       map[string]string `json:"groupLabels,omitempty"`
	Receiver          string            `json:"receiver,omitempty"`
	Status            string            `json:"status,omitempty"`
	TruncatedAlerts   int               `json:"truncatedAlerts,omitempty"`
	Version           string            `json:"version,omitempty"`
}

// CreateAlertJSONRequestBody defines body for CreateAlert for application/json ContentType.
type CreateAlertJSONRequestBody CreateAlertJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllAlerts request
	GetAllAlerts(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsByInstance request
	GetAlertsByInstance(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsBySeverity request
	GetAlertsBySeverity(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsToday request
	GetAlertsToday(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsYesterday request
	GetAlertsYesterday(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Statistics request
	Statistics(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAlertWithBody request with any body
	CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllAlerts(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsByInstance(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsByInstanceRequest(c.Server, instance, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsBySeverity(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsBySeverityRequest(c.Server, severity, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsToday(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsTodayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsYesterday(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsYesterdayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Statistics(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatisticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllAlertsRequest generates requests for GetAllAlerts
func NewGetAllAlertsRequest(server string, params *GetAllAlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsByInstanceRequest generates requests for GetAlertsByInstance
func NewGetAlertsByInstanceRequest(server string, instance string, params *GetAlertsByInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsBySeverityRequest generates requests for GetAlertsBySeverity
func NewGetAlertsBySeverityRequest(server string, severity string, params *GetAlertsBySeverityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "severity", runtime.ParamLocationPath, severity)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/severity/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsTodayRequest generates requests for GetAlertsToday
func NewGetAlertsTodayRequest(server string, params *GetAlertsTodayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/today")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsYesterdayRequest generates requests for GetAlertsYesterday
func NewGetAlertsYesterdayRequest(server string, params *GetAlertsYesterdayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/yesterday")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentType != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam0)
		}

	}

	return req, nil
}

// NewStatisticsRequest generates requests for Statistics
func NewStatisticsRequest(server string, params *StatisticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAlertRequest calls the generic CreateAlert builder with application/json body
func NewCreateAlertRequest(server string, body CreateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAlertRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAlertRequestWithBody generates requests for CreateAlert with any type of body
func NewCreateAlertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllAlertsWithResponse request
	GetAllAlertsWithResponse(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*GetAllAlertsResponse, error)

	// GetAlertsByInstanceWithResponse request
	GetAlertsByInstanceWithResponse(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*GetAlertsByInstanceResponse, error)

	// GetAlertsBySeverityWithResponse request
	GetAlertsBySeverityWithResponse(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*GetAlertsBySeverityResponse, error)

	// GetAlertsTodayWithResponse request
	GetAlertsTodayWithResponse(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*GetAlertsTodayResponse, error)

	// GetAlertsYesterdayWithResponse request
	GetAlertsYesterdayWithResponse(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*GetAlertsYesterdayResponse, error)

	// StatisticsWithResponse request
	StatisticsWithResponse(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*StatisticsResponse, error)

	// CreateAlertWithBodyWithResponse request with any body
	CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error)

	CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error)
}

type GetAllAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAllAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsByInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsByInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsByInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsBySeverityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsBySeverityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsBySeverityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsTodayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsTodayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsTodayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsYesterdayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alert
}

// Status returns HTTPResponse.Status
func (r GetAlertsYesterdayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsYesterdayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AlertDuration *[]struct {
			AverageDuration *int    `json:"average_duration,omitempty"`
			Name            *string `json:"name,omitempty"`
		} `json:"alert_duration,omitempty"`
		AlertsByDay *[]struct {
			AlertCount *int                `json:"alert_count,omitempty"`
			AlertDate  *openapi_types.Date `json:"alert_date,omitempty"`
		} `json:"alerts_by_day,omitempty"`
		AlertsByInstance *[]struct {
			Instance      *string `json:"instance,omitempty"`
			InstanceCount *int    `json:"instance_count,omitempty"`
		} `json:"alerts_by_instance,omitempty"`
		AlertsBySeverity *[]struct {
			AlertCount *int    `json:"alert_count,omitempty"`
			Severity   *string `json:"severity,omitempty"`
		} `json:"alerts_by_severity,omitempty"`
		AvgAlertDurationBySeverity *[]struct {
			AverageDuration *int    `json:"average_duration,omitempty"`
			Severity        *string `json:"severity,omitempty"`
		} `json:"avg_alert_duration_by_severity,omitempty"`
	}
	JSON400 *struct {
		Error *string `json:"error,omitempty"`
	}
	JSON500 *struct {
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllAlertsWithResponse request returning *GetAllAlertsResponse
func (c *ClientWithResponses) GetAllAlertsWithResponse(ctx context.Context, params *GetAllAlertsParams, reqEditors ...RequestEditorFn) (*GetAllAlertsResponse, error) {
	rsp, err := c.GetAllAlerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAlertsResponse(rsp)
}

// GetAlertsByInstanceWithResponse request returning *GetAlertsByInstanceResponse
func (c *ClientWithResponses) GetAlertsByInstanceWithResponse(ctx context.Context, instance string, params *GetAlertsByInstanceParams, reqEditors ...RequestEditorFn) (*GetAlertsByInstanceResponse, error) {
	rsp, err := c.GetAlertsByInstance(ctx, instance, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsByInstanceResponse(rsp)
}

// GetAlertsBySeverityWithResponse request returning *GetAlertsBySeverityResponse
func (c *ClientWithResponses) GetAlertsBySeverityWithResponse(ctx context.Context, severity string, params *GetAlertsBySeverityParams, reqEditors ...RequestEditorFn) (*GetAlertsBySeverityResponse, error) {
	rsp, err := c.GetAlertsBySeverity(ctx, severity, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsBySeverityResponse(rsp)
}

// GetAlertsTodayWithResponse request returning *GetAlertsTodayResponse
func (c *ClientWithResponses) GetAlertsTodayWithResponse(ctx context.Context, params *GetAlertsTodayParams, reqEditors ...RequestEditorFn) (*GetAlertsTodayResponse, error) {
	rsp, err := c.GetAlertsToday(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsTodayResponse(rsp)
}

// GetAlertsYesterdayWithResponse request returning *GetAlertsYesterdayResponse
func (c *ClientWithResponses) GetAlertsYesterdayWithResponse(ctx context.Context, params *GetAlertsYesterdayParams, reqEditors ...RequestEditorFn) (*GetAlertsYesterdayResponse, error) {
	rsp, err := c.GetAlertsYesterday(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsYesterdayResponse(rsp)
}

// StatisticsWithResponse request returning *StatisticsResponse
func (c *ClientWithResponses) StatisticsWithResponse(ctx context.Context, params *StatisticsParams, reqEditors ...RequestEditorFn) (*StatisticsResponse, error) {
	rsp, err := c.Statistics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatisticsResponse(rsp)
}

// CreateAlertWithBodyWithResponse request with arbitrary body returning *CreateAlertResponse
func (c *ClientWithResponses) CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error) {
	rsp, err := c.CreateAlertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResponse(rsp)
}

func (c *ClientWithResponses) CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error) {
	rsp, err := c.CreateAlert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResponse(rsp)
}

// ParseGetAllAlertsResponse parses an HTTP response from a GetAllAlertsWithResponse call
func ParseGetAllAlertsResponse(rsp *http.Response) (*GetAllAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsByInstanceResponse parses an HTTP response from a GetAlertsByInstanceWithResponse call
func ParseGetAlertsByInstanceResponse(rsp *http.Response) (*GetAlertsByInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsByInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsBySeverityResponse parses an HTTP response from a GetAlertsBySeverityWithResponse call
func ParseGetAlertsBySeverityResponse(rsp *http.Response) (*GetAlertsBySeverityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsBySeverityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsTodayResponse parses an HTTP response from a GetAlertsTodayWithResponse call
func ParseGetAlertsTodayResponse(rsp *http.Response) (*GetAlertsTodayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsTodayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseGetAlertsYesterdayResponse parses an HTTP response from a GetAlertsYesterdayWithResponse call
func ParseGetAlertsYesterdayResponse(rsp *http.Response) (*GetAlertsYesterdayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsYesterdayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseStatisticsResponse parses an HTTP response from a StatisticsWithResponse call
func ParseStatisticsResponse(rsp *http.Response) (*StatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AlertDuration *[]struct {
				AverageDuration *int    `json:"average_duration,omitempty"`
				Name            *string `json:"name,omitempty"`
			} `json:"alert_duration,omitempty"`
			AlertsByDay *[]struct {
				AlertCount *int                `json:"alert_count,omitempty"`
				AlertDate  *openapi_types.Date `json:"alert_date,omitempty"`
			} `json:"alerts_by_day,omitempty"`
			AlertsByInstance *[]struct {
				Instance      *string `json:"instance,omitempty"`
				InstanceCount *int    `json:"instance_count,omitempty"`
			} `json:"alerts_by_instance,omitempty"`
			AlertsBySeverity *[]struct {
				AlertCount *int    `json:"alert_count,omitempty"`
				Severity   *string `json:"severity,omitempty"`
			} `json:"alerts_by_severity,omitempty"`
			AvgAlertDurationBySeverity *[]struct {
				AverageDuration *int    `json:"average_duration,omitempty"`
				Severity        *string `json:"severity,omitempty"`
			} `json:"avg_alert_duration_by_severity,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseCreateAlertResponse parses an HTTP response from a CreateAlertWithResponse call
func ParseCreateAlertResponse(rsp *http.Response) (*CreateAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9zZxZ3W1+l8AAAD//6zOU7i4OAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
