//go:build go1.22

// Package webhooks provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package webhooks

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for GetAllAlertsParamsContentType.
const (
	GetAllAlertsParamsContentTypeApplicationjson GetAllAlertsParamsContentType = "application/json"
	GetAllAlertsParamsContentTypeTexthtml        GetAllAlertsParamsContentType = "text/html"
)

// Defines values for GetAlertsByInstanceParamsContentType.
const (
	GetAlertsByInstanceParamsContentTypeApplicationjson GetAlertsByInstanceParamsContentType = "application/json"
	GetAlertsByInstanceParamsContentTypeTexthtml        GetAlertsByInstanceParamsContentType = "text/html"
)

// Defines values for GetAlertsBySeverityParamsContentType.
const (
	GetAlertsBySeverityParamsContentTypeApplicationjson GetAlertsBySeverityParamsContentType = "application/json"
	GetAlertsBySeverityParamsContentTypeTexthtml        GetAlertsBySeverityParamsContentType = "text/html"
)

// Defines values for GetAlertsTodayParamsContentType.
const (
	GetAlertsTodayParamsContentTypeApplicationjson GetAlertsTodayParamsContentType = "application/json"
	GetAlertsTodayParamsContentTypeTexthtml        GetAlertsTodayParamsContentType = "text/html"
)

// Defines values for GetAlertsYesterdayParamsContentType.
const (
	GetAlertsYesterdayParamsContentTypeApplicationjson GetAlertsYesterdayParamsContentType = "application/json"
	GetAlertsYesterdayParamsContentTypeTexthtml        GetAlertsYesterdayParamsContentType = "text/html"
)

// Defines values for StatisticsParamsAccept.
const (
	StatisticsParamsAcceptApplicationjson StatisticsParamsAccept = "application/json"
	StatisticsParamsAcceptTexthtml        StatisticsParamsAccept = "text/html"
)

// Alert defines model for Alert.
type Alert struct {
	Annotations  map[string]string `json:"annotations,omitempty"`
	EndsAt       time.Time         `json:"endsAt,omitempty"`
	Fingerprint  string            `json:"fingerprint,omitempty"`
	GeneratorURL string            `json:"generatorURL,omitempty"`
	Labels       map[string]string `json:"labels,omitempty"`
	Receivers    []struct {
		Name string `json:"name,omitempty"`
	} `json:"receivers,omitempty"`
	StartsAt  time.Time `json:"startsAt,omitempty"`
	Status    Status    `json:"status,omitempty"`
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
}

// Status defines model for Status.
type Status struct {
	InhibitedBy []string `json:"inhibitedBy,omitempty"`
	SilencedBy  []string `json:"silencedBy,omitempty"`
	State       string   `json:"state,omitempty"`
}

// GetAllAlertsParams defines parameters for GetAllAlerts.
type GetAllAlertsParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAllAlertsParamsContentType `json:"Content-Type,omitempty"`
}

// GetAllAlertsParamsContentType defines parameters for GetAllAlerts.
type GetAllAlertsParamsContentType string

// GetAlertsByInstanceParams defines parameters for GetAlertsByInstance.
type GetAlertsByInstanceParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsByInstanceParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsByInstanceParamsContentType defines parameters for GetAlertsByInstance.
type GetAlertsByInstanceParamsContentType string

// GetAlertsBySeverityParams defines parameters for GetAlertsBySeverity.
type GetAlertsBySeverityParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsBySeverityParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsBySeverityParamsContentType defines parameters for GetAlertsBySeverity.
type GetAlertsBySeverityParamsContentType string

// GetAlertsTodayParams defines parameters for GetAlertsToday.
type GetAlertsTodayParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsTodayParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsTodayParamsContentType defines parameters for GetAlertsToday.
type GetAlertsTodayParamsContentType string

// GetAlertsYesterdayParams defines parameters for GetAlertsYesterday.
type GetAlertsYesterdayParams struct {
	// ContentType Content type of the request (e.g., application/json or text/html)
	ContentType *GetAlertsYesterdayParamsContentType `json:"Content-Type,omitempty"`
}

// GetAlertsYesterdayParamsContentType defines parameters for GetAlertsYesterday.
type GetAlertsYesterdayParamsContentType string

// StatisticsParams defines parameters for Statistics.
type StatisticsParams struct {
	// Accept Specify `application/json` or `text/html` to request JSON or HTML format.
	Accept *StatisticsParamsAccept `json:"Accept,omitempty"`
}

// StatisticsParamsAccept defines parameters for Statistics.
type StatisticsParamsAccept string

// CreateAlertJSONBody defines parameters for CreateAlert.
type CreateAlertJSONBody struct {
	Alerts []struct {
		Annotations  map[string]string `json:"annotations,omitempty"`
		EndsAt       time.Time         `json:"endsAt,omitempty"`
		Fingerprint  string            `json:"fingerprint,omitempty"`
		GeneratorURL string            `json:"generatorURL,omitempty"`
		Labels       map[string]string `json:"labels,omitempty"`
		StartsAt     time.Time         `json:"startsAt,omitempty"`
		Status       string            `json:"status,omitempty"`
	} `json:"alerts,omitempty"`
	CommonAnnotations map[string]string `json:"commonAnnotations,omitempty"`
	CommonLabels      map[string]string `json:"commonLabels,omitempty"`
	ExternalURL       string            `json:"externalURL,omitempty"`
	GroupKey          string            `json:"groupKey,omitempty"`
	GroupLabels       map[string]string `json:"groupLabels,omitempty"`
	Receiver          string            `json:"receiver,omitempty"`
	Status            string            `json:"status,omitempty"`
	TruncatedAlerts   int               `json:"truncatedAlerts,omitempty"`
	Version           string            `json:"version,omitempty"`
}

// CreateAlertJSONRequestBody defines body for CreateAlert for application/json ContentType.
type CreateAlertJSONRequestBody CreateAlertJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all alerts
	// (GET /alerts)
	GetAllAlerts(w http.ResponseWriter, r *http.Request, params GetAllAlertsParams)
	// Get alerts for a specific instance
	// (GET /alerts/instances/{instance})
	GetAlertsByInstance(w http.ResponseWriter, r *http.Request, instance string, params GetAlertsByInstanceParams)
	// Get alerts filtered by severity
	// (GET /alerts/severity/{severity})
	GetAlertsBySeverity(w http.ResponseWriter, r *http.Request, severity string, params GetAlertsBySeverityParams)
	// Get alerts for today
	// (GET /alerts/today)
	GetAlertsToday(w http.ResponseWriter, r *http.Request, params GetAlertsTodayParams)
	// Get alerts for yesterday
	// (GET /alerts/yesterday)
	GetAlertsYesterday(w http.ResponseWriter, r *http.Request, params GetAlertsYesterdayParams)
	// Retrieve alert statistics
	// (GET /statistics)
	Statistics(w http.ResponseWriter, r *http.Request, params StatisticsParams)
	// Create a new alert
	// (POST /webhook)
	CreateAlert(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAllAlerts operation middleware
func (siw *ServerInterfaceWrapper) GetAllAlerts(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllAlertsParams

	headers := r.Header

	// ------------- Optional header parameter "Content-Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Type")]; found {
		var ContentType GetAllAlertsParamsContentType
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Content-Type", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Content-Type", valueList[0], &ContentType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Content-Type", Err: err})
			return
		}

		params.ContentType = &ContentType

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllAlerts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlertsByInstance operation middleware
func (siw *ServerInterfaceWrapper) GetAlertsByInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "instance" -------------
	var instance string

	err = runtime.BindStyledParameterWithOptions("simple", "instance", r.PathValue("instance"), &instance, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instance", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlertsByInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "Content-Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Type")]; found {
		var ContentType GetAlertsByInstanceParamsContentType
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Content-Type", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Content-Type", valueList[0], &ContentType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Content-Type", Err: err})
			return
		}

		params.ContentType = &ContentType

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlertsByInstance(w, r, instance, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlertsBySeverity operation middleware
func (siw *ServerInterfaceWrapper) GetAlertsBySeverity(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "severity" -------------
	var severity string

	err = runtime.BindStyledParameterWithOptions("simple", "severity", r.PathValue("severity"), &severity, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "severity", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlertsBySeverityParams

	headers := r.Header

	// ------------- Optional header parameter "Content-Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Type")]; found {
		var ContentType GetAlertsBySeverityParamsContentType
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Content-Type", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Content-Type", valueList[0], &ContentType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Content-Type", Err: err})
			return
		}

		params.ContentType = &ContentType

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlertsBySeverity(w, r, severity, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlertsToday operation middleware
func (siw *ServerInterfaceWrapper) GetAlertsToday(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlertsTodayParams

	headers := r.Header

	// ------------- Optional header parameter "Content-Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Type")]; found {
		var ContentType GetAlertsTodayParamsContentType
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Content-Type", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Content-Type", valueList[0], &ContentType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Content-Type", Err: err})
			return
		}

		params.ContentType = &ContentType

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlertsToday(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlertsYesterday operation middleware
func (siw *ServerInterfaceWrapper) GetAlertsYesterday(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlertsYesterdayParams

	headers := r.Header

	// ------------- Optional header parameter "Content-Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Type")]; found {
		var ContentType GetAlertsYesterdayParamsContentType
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Content-Type", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Content-Type", valueList[0], &ContentType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Content-Type", Err: err})
			return
		}

		params.ContentType = &ContentType

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlertsYesterday(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Statistics operation middleware
func (siw *ServerInterfaceWrapper) Statistics(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params StatisticsParams

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept StatisticsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Statistics(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateAlert operation middleware
func (siw *ServerInterfaceWrapper) CreateAlert(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAlert(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/alerts", wrapper.GetAllAlerts)
	m.HandleFunc("GET "+options.BaseURL+"/alerts/instances/{instance}", wrapper.GetAlertsByInstance)
	m.HandleFunc("GET "+options.BaseURL+"/alerts/severity/{severity}", wrapper.GetAlertsBySeverity)
	m.HandleFunc("GET "+options.BaseURL+"/alerts/today", wrapper.GetAlertsToday)
	m.HandleFunc("GET "+options.BaseURL+"/alerts/yesterday", wrapper.GetAlertsYesterday)
	m.HandleFunc("GET "+options.BaseURL+"/statistics", wrapper.Statistics)
	m.HandleFunc("POST "+options.BaseURL+"/webhook", wrapper.CreateAlert)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9zZxZ3W1+l8AAAD//6zOU7i4OAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
